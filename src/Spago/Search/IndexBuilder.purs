module Spago.Search.IndexBuilder where

import Prelude

import Spago.Search.Config (config)
import Spago.Search.Declarations (Declarations(..), mkDeclarations)
import Spago.Search.Extra ((>#>))
import Spago.Search.Index (getPartId)
import Spago.Search.SearchResult (SearchResult)
import Spago.Search.TypeIndex (TypeIndex, mkTypeIndex)

import Data.Argonaut.Core (stringify)
import Data.Argonaut.Decode (decodeJson)
import Data.Argonaut.Encode (encodeJson)
import Data.Argonaut.Parser (jsonParser)
import Data.Array as Array
import Data.Either (Either(..))
import Data.List (List)
import Data.List as List
import Data.Map as Map
import Data.Maybe (Maybe(..))
import Data.Newtype (unwrap)
import Data.Search.Trie as Trie
import Data.Set as Set
import Data.String.CodePoints (contains) as String
import Data.String.CodeUnits (singleton) as String
import Data.String.Common (replace) as String
import Data.String.Pattern (Pattern(..)) as String
import Data.String.Pattern (Pattern(..), Replacement(..))
import Data.Traversable (for, for_)
import Data.Tuple (Tuple(..), fst, snd)
import Effect (Effect)
import Effect.Aff (Aff, launchAff_, parallel, sequential)
import Effect.Class (liftEffect)
import Effect.Console (log)
import Node.Encoding (Encoding(UTF8))
import Node.FS.Aff (exists, mkdir, readTextFile, readdir, stat, writeTextFile)
import Node.FS.Stats (isDirectory, isFile)
import Node.Process as Process
import Spago.Search.DocsJson (DocsJson)

main :: Effect Unit
main = launchAff_ mainAff

mainAff :: Aff Unit
mainAff = do
  checkDirectories

  docsJsons <- collectDocsJsons config.outputDirectory

  liftEffect $ log $
    "Found " <> show (Array.length docsJsons) <> " modules."

  let index = mkDeclarations docsJsons
      typeIndex = mkTypeIndex index

  createDirectories

  void $ sequential do
    ignore <$> parallel (writeIndex index)
           <*> parallel (writeTypeIndex typeIndex)
           <*> parallel patchDocs

  liftEffect $ log $
    "Loaded " <>
    show (Trie.size $ unwrap index) <>
    " definitions and " <>
    show (List.length $ join $ map snd $ Trie.entriesUnordered (unwrap index)) <>
    " type definitions"
  where ignore _ _ _ = unit

-- | Exit early if something is missing.
checkDirectories :: Aff Unit
checkDirectories = do
  for_ config.requiredDirectories \dir -> do
    whenM (not <$> directoryExists dir) $
      liftEffect $ do
        log "Run `spago build && spago docs` first!"
        Process.exit 1

-- | Read and decode all `docs.json` files in the `outputDir`.
collectDocsJsons :: String -> Aff (Array DocsJson)
collectDocsJsons outputDir = do
  paths <- readdir outputDir

  mbs <- for paths \moduleName -> do
    let jsonFile = "output/" <> moduleName <> "/docs.json"
    doesExist <- fileExists jsonFile
    if doesExist then do

      contents <- readTextFile UTF8 jsonFile
      let eiResult = jsonParser contents >>= decodeJson

      case eiResult of
        Left error -> do
          liftEffect $ log $
            "`docs.json` decoding failed failed for module " <> moduleName <> ": " <> show error
          pure Nothing
        Right result -> pure result

    else do
      liftEffect $ do
        log $
          "Couldn't find docs.json for " <> moduleName
      pure Nothing

  pure $ Array.catMaybes mbs

writeTypeIndex :: TypeIndex -> Aff Unit
writeTypeIndex typeIndex =
  for_ entries \(Tuple typeShape results) -> do
    writeTextFile UTF8 ("generated-docs/index/types/" <> typeShape <> ".js")
      (mkHeader typeShape <> stringify (encodeJson results))
  where
    mkHeader typeShape =
      "// This file was generated by spago\n" <>
      "window.spagoTypeIndex[\"" <> typeShape <> "\"] = "
    entries :: Array _
    entries = Map.toUnfoldableUnordered (unwrap typeIndex)

writeIndex :: Declarations -> Aff Unit
writeIndex (Declarations trie) = do
  let
    prefixes :: Array (List Char)
    prefixes =
        Set.toUnfoldable $
        List.foldr (\entry -> Set.insert (List.take 2 $ fst entry)) mempty $
        Trie.entriesUnordered trie

    parts
      :: Array { prefix :: List Char
               , results :: Array (Tuple String (Array SearchResult))
               }
    parts = prefixes <#> \prefix ->
      let results =
            Array.fromFoldable $
            Trie.query prefix trie <#>
            \(Tuple path value) ->
            Tuple (path >#> String.singleton) (Array.fromFoldable value)
      in
       { prefix, results }

    resultsMap = Array.foldr (\part -> Map.insertWith append (getPartId part.prefix) part) mempty parts

  for_ (Map.toUnfoldableUnordered resultsMap :: Array _)
    \(Tuple indexPartId results) -> do
      let header =
            "// This file was generated by spago.\n" <>
            "window.spagoIndex[\"" <> show indexPartId <> "\"] = "

      writeTextFile UTF8 (config.mkIndexPartPath indexPartId) $
        header <> stringify (encodeJson results)

patchDocs :: Aff Unit
patchDocs = do
  let dirname = "generated-docs/"
      pattern = Pattern "</body>"
      patch = "<!-- Spago search index. -->" <>
              "<script type=\"text/javascript\" src=\"../spago-search-app.js\"></script>" <>
              "<script type=\"text/javascript\">" <>
              "window.spagoTypeIndex = {};" <>
              "window.spagoIndex = {};" <>
              "</script>" <>
              "</body>"

  files <- readdir (dirname <> "html")

  for_ files \file -> do
    let path = dirname <> "html/" <> file

    whenM (fileExists path) do
      contents <- readTextFile UTF8 path
      when (not $ String.contains (String.Pattern patch) contents) do
        writeTextFile UTF8 path $
          String.replace pattern (Replacement patch) contents

createDirectories :: Aff Unit
createDirectories = do
  let generatedDocsDir = "generated-docs/"
      indexDir         = "generated-docs/index"
      declIndexDir     = "generated-docs/index/declarations"
      typeIndexDir     = "generated-docs/index/types"

  whenM (not <$> directoryExists generatedDocsDir) $ liftEffect do
    logAndExit "Run `spago docs` first!"

  whenM (not <$> directoryExists indexDir) do
    mkdir indexDir

  whenM (not <$> directoryExists declIndexDir) do
    mkdir declIndexDir

  whenM (not <$> directoryExists typeIndexDir) do
    mkdir typeIndexDir

directoryExists :: String -> Aff Boolean
directoryExists path = do
  doesExist <- exists path
  case doesExist of
    false -> pure false
    true -> isDirectory <$> stat path

fileExists :: String -> Aff Boolean
fileExists path = do
  doesExist <- exists path
  case doesExist of
    false -> pure false
    true -> isFile <$> stat path

logAndExit :: forall a. String -> Effect a
logAndExit err = do
  log err
  Process.exit 1
